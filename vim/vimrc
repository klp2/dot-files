" let vim-perl and vim-go handle those languages directly, as
" vim-polyglot can take some time to pull in their updates
let g:polyglot_disabled = ['go', 'perl', 'raku']

call plug#begin('~/.vim/plugged')

" perl stuff
Plug 'c9s/perlomni.vim'
Plug 'vim-perl/vim-perl'
Plug 'yko/mojo.vim'

" golang stuff
Plug 'fatih/vim-go'

" SQL stuff
Plug 'oalders/prettysql'

" JSON stuff
Plug 'vim-scripts/vim-json-bundle'

" assembly stuff
Plug 'zacharied/lc3.vim'

" general programming language stuff
Plug 'andymass/vim-matchup'
Plug 'bkad/CamelCaseMotion'
Plug 'mattn/webapi-vim'
Plug 'ntpeters/vim-better-whitespace'
Plug 'sheerun/vim-polyglot'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
Plug 'w0rp/ale'

" git stuff
Plug 'airblade/vim-gitgutter'
Plug 'mattn/gist-vim'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-rhubarb'
Plug 'github/copilot.vim'

" look and feel stuff
Plug 'dracula/vim', { 'as': 'dracula' }
Plug 'joshdick/onedark.vim'
Plug 'vim-airline/vim-airline-themes'

" utility stuff
Plug 'bling/vim-airline'
Plug 'embear/vim-foldsearch'
Plug 'jceb/vim-hier'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() }}
Plug 'junegunn/fzf.vim', { 'dir': '~/.fzf', 'do': './install -all', 'frozen': 1 }
Plug 'junegunn/vim-easy-align'
Plug 'klp2/dc_automakedir'
Plug 'rhysd/accelerated-jk'

" $work-specific stuff - only load if mm-perl exists
if executable('mm-perl')
    Plug 'https://github.maxmind.com/maxmind/mm.vim', { 'frozen': 1 }
endif

call plug#end()

" Set colorscheme (with fallback for first install before PlugInstall)
try
  colorscheme dracula
catch /^Vim\%((\a\+)\)\=:E185/
  " Dracula not installed yet, use default
endtry

"set a line on the right side to visually remind us to avoid long lines
set cc=90

function! GitStatus()
  let [a,m,r] = GitGutterGetHunkSummary()
  return printf('+%d ~%d -%d', a, m, r)
endfunction

let g:airline_theme='luna'
set statusline+=%{GitStatus()}
set laststatus=2
set bs=2

" gives us count of search matches
set shortmess-=S

map zg :GitGutterFold<CR>

"====[ Use persistent undo ]=================

if has('persistent_undo')
    " Save all undo files in a single location (less messy, more risky)...
    set undodir=$HOME/.vimundo

    " Save a lot of back-history...
    set undolevels=5000

    " Actually switch on persistent undo
    set undofile

endif


"=====[ Adjust keyword characters to match Perlish identifiers ]===============

set iskeyword+=$
set iskeyword+=%
set iskeyword+=@-@
set iskeyword+=:
set iskeyword-=,

"=====[ Correct common mistypings in-the-fly ]=======================

iab    retrun  return
iab     pritn  print
iab      Pelr  Perl
iab      pelr  perl

"=====[ Search folding (vim-foldsearch) ]=====================

" Don't start new buffers folded
set foldlevelstart=99

" Highlight folds
highlight Folded  ctermfg=cyan ctermbg=black

" Toggle fold around current search - zz to fold, zz again to unfold
let g:search_folded = 0
function! ToggleFoldSearch()
    if g:search_folded
        normal! zE
        let g:search_folded = 0
    else
        Fs
        let g:search_folded = 1
    endif
endfunction
nmap <silent> zz :call ToggleFoldSearch()<CR>

" Fold to show only subroutines/functions
nmap <silent> zp :Fs /^\s*\%(sub\<bar>func\<bar>method\<bar>package\)\s\+\k\+/<CR>

" Unfold everything
nmap <silent> zE :normal! zE<CR>:let g:search_folded = 0<CR>



"=====[ Smarter interstitial completions of identifiers ]=============
"
" When autocompleting within an identifier, prevent duplications...

augroup Undouble_Completions
    autocmd!
    autocmd CompleteDone *  call Undouble_Completions()
augroup END

function! Undouble_Completions ()
    let col  = getpos('.')[2]
    let line = getline('.')
    call setline('.', substitute(line, '\(\.\?\k\+\)\%'.col.'c\zs\1', '', ''))
endfunction
"=====[ ,, as => without delays ]===================

inoremap <expr><silent>  ,  Smartcomma()

function! Smartcomma ()
    let [bufnum, lnum, col, off, curswant] = getcurpos()
    if getline('.') =~ (',\%' . (col+off) . 'c')
        return "\<C-H>=>"
    else
        return ','
    endif
endfunction

"=====[ Configure Hier for error highlighting ]===================
" You also need to install the following:  https://github.com/jceb/vim-hier

highlight HierError    ctermfg=red     cterm=bold
highlight HierWarning  ctermfg=magenta cterm=bold

let g:hier_highlight_group_qf  = 'HierError'
let g:hier_highlight_group_qfw = 'HierWarning'

let g:hier_highlight_group_loc  = 'Normal'
let g:hier_highlight_group_locw = 'HierWarning'
let g:hier_highlight_group_loci = 'Normal'

"====[ Golang stuff ]=====
let g:go_fmt_command = "gopls"
let g:go_template_autocreate = 0  " Use <leader>gomain instead
" get signature/type info for object under cursor
let g:go_auto_type_info = 1
map <leader>gt :GoTest<cr>

"=====[ Configure ALE for error tracking ]==================
" You also need to install the following:  https://github.com/w0rp/ale

highlight AleError    ctermfg=red     cterm=bold
highlight AleWarning  ctermfg=magenta cterm=bold

augroup ALE_Autoconfig
    au!
    autocmd User GVI_Start  silent call Stop_ALE()
    autocmd User PV_Start   silent call Stop_ALE()
    autocmd User PV_End     silent call Start_ALE()
    autocmd User ALELint    silent HierUpdate
augroup END

let g:ale_set_loclist                = 0
let g:ale_set_quickfix               = 1
let g:ale_set_signs                  = 0
let g:ale_linters = {'go': ['gofumpt', 'gopls', 'golint', 'go vet', 'golangci-lint'], 'perl': ['perl','perlcritic'] }
let g:ale_fixers =  { 'perl': ['perltidy'] }

nmap <silent> ;m [Toggle automake on Perl files] :call Toggle_ALE()<CR>

function! Start_ALE ()
    ALEEnable
    HierStart
endfunction

function! Stop_ALE ()
    silent call s:ChangeProfile(&filetype)
    ALEDisable
    HierStop
    call setqflist([])
    redraw!
endfunction

function! Toggle_ALE ()
    if g:ale_enabled
        call Stop_ALE()
    else
        call Start_ALE()
    endif
    echo 'Error highlighting ' . (g:ale_enabled ? 'on' : 'off')
endfunction

nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)

" Indent using tabs (while in visual mode)
vnoremap < <gv
vnoremap > >gv
" make tab in v mode ident code
vmap <tab> >gv
vmap <s-tab> <gv
" make tab in normal mode ident code
nmap <tab> I<tab><esc>
nmap <s-tab> ^i<bs><esc>

" case insensitive search
set ignorecase smartcase

" highlight all matches
set hlsearch

" lookahead as search pattern is specified
set incsearch

""Delete in normal mode to switch off highlighting till next search and clear messages...
"Nmap <silent> <BS> [Cancel highlighting]  :call HLNextOff() <BAR> :nohlsearch <BAR> :call VG_Show_CursorColumn('off')<CR>::HierClear<CR>

""Double-delete to remove trailing whitespace...
"Nmap <silent> <BS><BS>  [Remove trailing whitespace] mz:call TrimTrailingWS()<CR>`z

function! TrimTrailingWS ()
    if search('\s\+$', 'cnw')
        :%s/\s\+$//g
    endif
endfunction

" indents
set smartindent
set autoindent

" reload files which have changed
:au CursorHold * checktime
set autoread

" show matching brackets
autocmd FileType perl set showmatch

" show line numbers
autocmd FileType perl set number

let mapleader = ","

"command -range=% -nargs=* Tidy <line1>,<line2>!
"  \perltidy -pbp <args>

nnoremap <silent> = :%!perltidy -q<Enter>
vnoremap <silent> = :!perltidy -q<Enter>

"remove all trailing whitespace
:nnoremap <leader>s :StripWhitespace<CR>
:vnoremap <leader>s :StripWhitespace<CR>

"dictionary sort
:vnoremap <silent> so :!sort -d<CR>

"dictionary sort unique
:vnoremap <silent> su :!sort -d <bar> uniq<CR>

"pretty print json
map <leader>jt <Esc>:%!json_xs -f json -t json-pretty<CR>

:set list!
:set listchars=tab:\|-

autocmd FileType go :set nolist

" enables shift-tab for outdent
exe 'set t_kB=' . nr2char(27) . '[Z'

" reflow text
nnoremap Q gqap
vnoremap Q gq

" highlight comments
highlight Comment term=bold ctermfg=white

"====[ Goto last location in non-empty files ]=======

autocmd BufReadPost *  if line("'\"") > 1 && line("'\"") <= line("$")
                   \|     exe "normal! g`\""
                   \|  endif

set stl=%f\ %m\ %r%{fugitive#statusline()}\ Line:%l/%L[%p%%]\ Col:%v\ Buf:#%n\ [%b][0x%B]

" paste the same line multiple times without the content of the "yank" being replaced
" http://stackoverflow.com/questions/7163947/vim-paste-multiple-times
xnoremap p pgvy

" https://github.com/jonswar/perl-code-tidyall/blob/master/etc/editors/tidyall.vim

" Run tidyall on the current buffer. If an error occurs, show it and leave it
" in tidyall.ERR, and undo any changes.

command! T :call TidyAll()

command! TidyAll :call TidyAll()
function! TidyAll()
    let cur_pos = getpos( '.' )
    let cmdline = ':1,$!tidyall --mode editor --pipe %:p 2> tidyall.ERR'
    execute( cmdline )
    if v:shell_error
        echo "\nContents of tidyall.ERR:\n\n" . system( 'cat tidyall.ERR' )
        silent undo
    else
        call system( 'rm tidyall.ERR' )
    endif
    call setpos( '.', cur_pos )
endfunction

" Bind to ,t (or leader+t)
map <leader>T :TidyAll<cr>

" fzf file finder (replaces Command-T)
map <leader>f :Files<cr>

" we set updatime this low to see better gitgutter results
set updatetime=100

" http://stackoverflow.com/questions/1327978/sorting-words-not-lines-in-vim
:vnoremap <F1> d:execute 'normal a' . join(sort(split(getreg('"'))), ' ')<CR>

set statusline+=%#warningmsg#
set statusline+=%*

" Language templates
function! PerlTemplate()
  set paste
  if expand('%:e') == 'pm'
    " Module template - package name from file path
    let l:pkg = substitute(expand('%:r'), '/', '::', 'g')
    let l:pkg = substitute(l:pkg, '^lib::', '', '')
    let l:pkg = substitute(l:pkg, '^t::lib::', '', '')
    execute "normal! Opackage " . l:pkg . ";\<CR>\<CR>use strict;\<CR>use warnings;\<CR>\<CR>\<CR>1;\<ESC>"
    normal! 2k
  else
    " Script template
    execute "normal! O#!/usr/bin/env perl\<CR>\<CR>use strict;\<CR>use warnings;\<CR>use feature qw( say );\<CR>\<CR>\<ESC>"
  endif
  set nopaste
endfunction
map <leader>perl :call PerlTemplate()<CR>
map <leader>gomain :set paste<CR>Opackage main<CR><CR>func main() {<CR>}<CR><ESC>:set nopaste<CR>kO

" convert a file path to a Perl module name
" ie Foo/Bar/Baz.pm => Foo::Bar::Baz
map ,2mod :s/\.pm//<CR>gv:s/\//::/g<CR>

map <silent> w <Plug>CamelCaseMotion_w
map <silent> b <Plug>CamelCaseMotion_b
map <silent> e <Plug>CamelCaseMotion_e
map <silent> ge <Plug>CamelCaseMotion_ge
sunmap w
sunmap b
sunmap e
sunmap ge

" tabs
set softtabstop=4
set shiftwidth=4
set tabstop=4
set smarttab
" use spaces rather than tabs
set expandtab

" 4 space tabs in html get annoying
au BufRead,BufNewFile *.tmpl set filetype=html
autocmd FileType html :setlocal sw=2 ts=2 sts=2

au BufRead,BufNewFile *.yml set filetype=yaml
autocmd FileType yaml :setlocal sw=2 ts=2 sts=2

" Treat Mojo templates (mostly) like HTML
autocmd FileType html.epl setlocal sw=2 ts=2 sts=2

" Don't override iTerm2's window transparency
hi Normal ctermbg=none

" Accelerated up and down on wrapped lines
"nnoremap  j  gj
"nnoremap  k  gk
nmap j <Plug>(accelerated_jk_gj)
nmap k <Plug>(accelerated_jk_gk)

" vim-easy-align - Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" FZF
nmap ; :Buffers<CR>
nmap <leader>r :Tags<CR>
nmap <leader>t :Files<CR>
nmap <leader>a :Ag<CR>

" Window navigation (match neovim)
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Bash template
function! BashTemplate()
  set paste
  execute "normal! O#!/usr/bin/env bash\<CR>\<CR>set -eu -o pipefail\<CR>\<CR>\<ESC>"
  set nopaste
endfunction
map <leader>bash :call BashTemplate()<CR>

source ~/.local_vimrc
